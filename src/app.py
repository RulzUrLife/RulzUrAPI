"""Entry point of the application

Run on 0.0.0.0 by default (not configurable yet)

"""
import flask
import logging
import os

import werkzeug.exceptions as werkzeug_exc

import api.base as base
import api.utensils as utensils
import api.recipes as recipes
import api.ingredients as ingredients

import db
import utils.exceptions as exc
import utils.helpers as helpers


class Flask(flask.Flask):
    """RulzUrKitchen specific Flask app"""

    def make_response(self, rv):
        data, code, headers = helpers.unpack(rv)
        tpl = getattr(flask.request, 'tpl', None)
        if tpl is not None:
            rv = flask.render_template(tpl, **data), code, headers
        elif isinstance(data, dict):
            headers.update({'Content-Type': 'application/json'})
            rv = flask.json.dumps(data), code, headers

        return super(Flask, self).make_response(rv)


class Request(flask.Request):
    def on_json_loading_failed(self, _):
        raise exc.APIException(
            'request malformed', 400, {'errors': 'JSON is incorrect'}
        )

def create_app(conf=None):
    conf = conf or {}
    app = Flask(__name__, static_folder=None)

    app.config.from_object('settings')
    app.config.from_pyfile('local_settings.py', silent=True)
    app.config.from_object(os.environ.get('RULZURAPI_SETTINGS', None))
    app.config.update(conf)

    # Change default encoder
    app.json_encoder = helpers.JSONEncoder

    # Override default request object
    app.request_class = Request

    # Logging support
    loggers = [app.logger,
               logging.getLogger('peewee'),
               logging.getLogger('werkzeug')]

    # DB connection
    db.database.init(**app.config['DATABASE'])

    @app.before_request
    def db_connect():
        """ This hook ensures that a connection is opened to handle any queries
        generated by the request."""
        flask.g.database = db.database
        flask.g.database.connect()


    @app.teardown_request
    def db_close(_):
        """This hook ensures that the connection is closed when we've finished
        processing the request.
        """
        if not flask.g.database.is_closed():
            flask.g.database.close()


    for logger in loggers:
        log_format = (app.config['DEBUG_LOG_FORMAT'] if app.config['DEBUG']
                      else app.config['PROD_LOG_FORMAT'])

        handler = (logging.StreamHandler() if app.config['DEBUG']
                   else logging.FileHandler(app.config['LOG_FILE']))
        handler.setFormatter(logging.Formatter(log_format))

        logger.setLevel(logging.DEBUG if app.config['DEBUG'] else logging.WARN)
        logger.addHandler(handler)


    # Register error handlers
    app.register_error_handler(exc.APIException, exc.dump_api_exc)

    # Register blueprints
    app.register_blueprint(base.blueprint, url_prefix='')
    app.register_blueprint(utensils.blueprint, url_prefix='/utensils')
    app.register_blueprint(recipes.blueprint, url_prefix='/recipes')
    app.register_blueprint(ingredients.blueprint, url_prefix='/ingredients')
    return app


if __name__ == "__main__":
    create_app().run(host='0.0.0.0', use_reloader=False)
